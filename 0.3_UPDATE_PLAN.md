# A2A Protocol v0.3.0 Update Plan

## Overview

This document outlines the changes required to update the `a2a-rs` crate from its current implementation to comply with the A2A Protocol v0.3.0 specification. The specification is located in the `spec/` folder, with a detailed changelog in `spec/CHANGELOG.md`.

## Current Status

The a2a-rs crate currently implements an earlier version (likely v0.2.x) of the A2A protocol. The v0.3.0 specification introduces several breaking changes and new features that need to be implemented.

## Key Changes Summary

### Breaking Changes

1. **AgentCard** - New required field `protocolVersion`, renamed `signature` → `signatures`
2. **Error Codes** - New error code -32007 conflicts with current DATABASE_ERROR
3. **MessageSendConfiguration** - `acceptedOutputModes` is now optional

### New Features

1. **Multi-transport support** - Agents can declare multiple transport protocols
2. **Extensions framework** - First-class support for protocol extensions
3. **Task listing** - New `tasks/list` method with filtering and pagination
4. **Enhanced push notifications** - Multiple configs per task with list/delete operations
5. **Authenticated extended cards** - New `agent/getAuthenticatedExtendedCard` method
6. **mTLS support** - New security scheme type

## Detailed Changes

### 1. AgentCard Breaking Changes (High Priority)

**File:** `a2a-rs/src/domain/core/agent.rs`

#### Current State
```rust
pub struct AgentCard {
    pub name: String,
    pub description: String,
    pub url: String,
    // ... other fields
    pub signature: Option<AgentCardSignature>,  // ❌ Should be plural
    pub supports_authenticated_extended_card: Option<bool>,
}
```

#### Required Changes
```rust
pub struct AgentCard {
    // NEW REQUIRED FIELD - defaults to "0.3.0"
    #[serde(default = "default_protocol_version")]
    pub protocol_version: String,

    // NEW OPTIONAL FIELD - defaults to "JSONRPC"
    #[serde(default = "default_preferred_transport", rename = "preferredTransport")]
    pub preferred_transport: String,

    // NEW: Support for multiple transport protocols
    #[serde(skip_serializing_if = "Option::is_none", rename = "additionalInterfaces")]
    pub additional_interfaces: Option<Vec<AgentInterface>>,

    // NEW: Icon URL for the agent
    #[serde(skip_serializing_if = "Option::is_none", rename = "iconUrl")]
    pub icon_url: Option<String>,

    // CHANGED: signature → signatures (now an array)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub signatures: Option<Vec<AgentCardSignature>>,  // ✅ Plural, Vec

    // ... existing fields
}

fn default_protocol_version() -> String {
    "0.3.0".to_string()
}

fn default_preferred_transport() -> String {
    "JSONRPC".to_string()
}
```

**Impact:** Breaking change - users must update `signature` to `signatures` and wrap in Vec.

---

### 2. New Core Types (High Priority)

**File:** `a2a-rs/src/domain/core/agent.rs`

#### TransportProtocol Enum
```rust
/// Supported A2A transport protocols (v0.3.0)
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "UPPERCASE")]
pub enum TransportProtocol {
    #[serde(rename = "JSONRPC")]
    JsonRpc,
    #[serde(rename = "GRPC")]
    Grpc,
    #[serde(rename = "HTTP+JSON")]
    HttpJson,
}
```

#### AgentInterface
```rust
/// Declares a combination of URL and transport protocol (v0.3.0)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AgentInterface {
    /// The URL where this interface is available
    pub url: String,

    /// The transport protocol supported at this URL
    pub transport: String,  // Could also use TransportProtocol enum
}
```

#### AgentExtension
```rust
/// Declaration of a protocol extension supported by an agent (v0.3.0)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AgentExtension {
    /// Unique URI identifying the extension
    pub uri: String,

    /// Human-readable description of the extension
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,

    /// Whether the client must understand this extension
    #[serde(skip_serializing_if = "Option::is_none")]
    pub required: Option<bool>,

    /// Extension-specific configuration parameters
    #[serde(skip_serializing_if = "Option::is_none")]
    pub params: Option<HashMap<String, serde_json::Value>>,
}
```

---

### 3. AgentCapabilities Update (Medium Priority)

**File:** `a2a-rs/src/domain/core/agent.rs`

#### Current State
```rust
pub struct AgentCapabilities {
    #[serde(default)]
    pub streaming: bool,
    #[serde(default, rename = "pushNotifications")]
    pub push_notifications: bool,
    #[serde(default, rename = "stateTransitionHistory")]
    pub state_transition_history: bool,
}
```

#### Required Addition
```rust
pub struct AgentCapabilities {
    // ... existing fields

    /// List of protocol extensions supported by the agent (v0.3.0)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub extensions: Option<Vec<AgentExtension>>,
}
```

---

### 4. Message & Artifact Extensions (Medium Priority)

**Files:**
- `a2a-rs/src/domain/core/message.rs` (Message struct)
- `a2a-rs/src/domain/core/message.rs` (Artifact struct)

#### Message Update
```rust
pub struct Message {
    // ... existing fields

    /// URIs of extensions relevant to this message (v0.3.0)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub extensions: Option<Vec<String>>,
}
```

#### Artifact Update
```rust
pub struct Artifact {
    // ... existing fields

    /// URIs of extensions relevant to this artifact (v0.3.0)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub extensions: Option<Vec<String>>,
}
```

---

### 5. PushNotificationConfig Update (Medium Priority)

**File:** `a2a-rs/src/domain/core/agent.rs`

#### Current State
```rust
pub struct PushNotificationConfig {
    pub url: String,
    pub token: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub authentication: Option<PushNotificationAuthenticationInfo>,
}
```

#### Required Addition
```rust
pub struct PushNotificationConfig {
    /// Unique identifier for the push notification config (v0.3.0)
    /// Allows multiple notification callbacks per task
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    // ... existing fields
}
```

---

### 6. New API Method: tasks/list (High Priority)

**File:** `a2a-rs/src/domain/core/task.rs` (or new file for task listing)

#### ListTasksParams
```rust
/// Parameters for listing tasks with filtering and pagination (v0.3.0)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ListTasksParams {
    /// Filter tasks by context ID
    #[serde(skip_serializing_if = "Option::is_none", rename = "contextId")]
    pub context_id: Option<String>,

    /// Filter tasks by their current status state
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<TaskState>,

    /// Maximum number of tasks to return (1-100, default 50)
    #[serde(skip_serializing_if = "Option::is_none", rename = "pageSize")]
    pub page_size: Option<i32>,

    /// Token for pagination from previous response
    #[serde(skip_serializing_if = "Option::is_none", rename = "pageToken")]
    pub page_token: Option<String>,

    /// Number of recent messages to include (default 0)
    #[serde(skip_serializing_if = "Option::is_none", rename = "historyLength")]
    pub history_length: Option<i32>,

    /// Whether to include artifacts (default false)
    #[serde(skip_serializing_if = "Option::is_none", rename = "includeArtifacts")]
    pub include_artifacts: Option<bool>,

    /// Filter tasks updated after this timestamp (ms since epoch)
    #[serde(skip_serializing_if = "Option::is_none", rename = "lastUpdatedAfter")]
    pub last_updated_after: Option<i64>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub metadata: Option<Map<String, Value>>,
}
```

#### ListTasksResult
```rust
/// Result object for tasks/list method (v0.3.0)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ListTasksResult {
    /// Array of tasks matching the criteria
    pub tasks: Vec<Task>,

    /// Total number of tasks available (before pagination)
    #[serde(rename = "totalSize")]
    pub total_size: i32,

    /// Maximum number of tasks in this response
    #[serde(rename = "pageSize")]
    pub page_size: i32,

    /// Token for next page (empty string if no more results)
    #[serde(rename = "nextPageToken")]
    pub next_page_token: String,
}
```

#### Request/Response Types
```rust
/// Request for tasks/list method (v0.3.0)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ListTasksRequest {
    pub jsonrpc: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<Value>,
    pub method: String,  // "tasks/list"
    #[serde(skip_serializing_if = "Option::is_none")]
    pub params: Option<ListTasksParams>,
}

/// Response for tasks/list method (v0.3.0)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ListTasksResponse {
    pub jsonrpc: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub result: Option<ListTasksResult>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error: Option<JSONRPCError>,
}
```

---

### 7. Enhanced Push Notification Config Methods (High Priority)

**File:** `a2a-rs/src/domain/core/task.rs`

#### Get Config - Enhanced Parameters
```rust
/// Parameters for getting a specific push notification config (v0.3.0)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetTaskPushNotificationConfigParams {
    /// Task ID
    pub id: String,

    /// Specific config ID to retrieve (optional)
    #[serde(skip_serializing_if = "Option::is_none", rename = "pushNotificationConfigId")]
    pub push_notification_config_id: Option<String>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub metadata: Option<Map<String, Value>>,
}
```

**Note:** The existing `GetTaskPushNotificationConfigRequest` should accept either `TaskIdParams` OR `GetTaskPushNotificationConfigParams` in its params field.

#### List Configs
```rust
/// Parameters for listing all push notification configs for a task (v0.3.0)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ListTaskPushNotificationConfigParams {
    pub id: String,  // Task ID
    #[serde(skip_serializing_if = "Option::is_none")]
    pub metadata: Option<Map<String, Value>>,
}

/// Request for tasks/pushNotificationConfig/list
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ListTaskPushNotificationConfigRequest {
    pub jsonrpc: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<Value>,
    pub method: String,  // "tasks/pushNotificationConfig/list"
    pub params: ListTaskPushNotificationConfigParams,
}

/// Response for tasks/pushNotificationConfig/list
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ListTaskPushNotificationConfigResponse {
    pub jsonrpc: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub result: Option<Vec<TaskPushNotificationConfig>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error: Option<JSONRPCError>,
}
```

#### Delete Config
```rust
/// Parameters for deleting a push notification config (v0.3.0)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeleteTaskPushNotificationConfigParams {
    pub id: String,  // Task ID
    #[serde(rename = "pushNotificationConfigId")]
    pub push_notification_config_id: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub metadata: Option<Map<String, Value>>,
}

/// Request for tasks/pushNotificationConfig/delete
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeleteTaskPushNotificationConfigRequest {
    pub jsonrpc: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<Value>,
    pub method: String,  // "tasks/pushNotificationConfig/delete"
    pub params: DeleteTaskPushNotificationConfigParams,
}

/// Response for tasks/pushNotificationConfig/delete (returns null on success)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeleteTaskPushNotificationConfigResponse {
    pub jsonrpc: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub result: Option<Value>,  // null on success
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error: Option<JSONRPCError>,
}
```

---

### 8. Authenticated Extended Card (High Priority)

**File:** `a2a-rs/src/application/handlers/agent.rs` (or new file)

#### Request/Response Types
```rust
/// Request for agent/getAuthenticatedExtendedCard (v0.3.0)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetAuthenticatedExtendedCardRequest {
    pub jsonrpc: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<Value>,
    pub method: String,  // "agent/getAuthenticatedExtendedCard"
    // No params required
}

/// Response for agent/getAuthenticatedExtendedCard
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetAuthenticatedExtendedCardResponse {
    pub jsonrpc: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub result: Option<AgentCard>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error: Option<JSONRPCError>,
}
```

---

### 9. Error Code Updates (Critical Priority)

**File:** `a2a-rs/src/domain/error.rs`

#### Current Problem
```rust
pub const DATABASE_ERROR: i32 = -32007;  // ❌ CONFLICTS with spec
```

The spec defines `-32007` as `AUTHENTICATED_EXTENDED_CARD_NOT_CONFIGURED`.

#### Required Changes
```rust
// A2A specific error codes
pub const TASK_NOT_FOUND: i32 = -32001;
pub const TASK_NOT_CANCELABLE: i32 = -32002;
pub const PUSH_NOTIFICATION_NOT_SUPPORTED: i32 = -32003;
pub const UNSUPPORTED_OPERATION: i32 = -32004;
pub const CONTENT_TYPE_NOT_SUPPORTED: i32 = -32005;
pub const INVALID_AGENT_RESPONSE: i32 = -32006;
pub const AUTHENTICATED_EXTENDED_CARD_NOT_CONFIGURED: i32 = -32007;  // ✅ NEW

// Custom application-specific error codes (outside spec range)
pub const DATABASE_ERROR: i32 = -32100;  // ✅ MOVED to avoid conflict
```

#### New Error Variant
```rust
pub enum A2AError {
    // ... existing variants

    #[error("Authenticated extended card not configured")]
    AuthenticatedExtendedCardNotConfigured,

    // ... rest of variants
}
```

Update the `to_jsonrpc_error()` method:
```rust
impl A2AError {
    pub fn to_jsonrpc_error(&self) -> serde_json::Value {
        let (code, message) = match self {
            // ... existing cases

            A2AError::AuthenticatedExtendedCardNotConfigured => (
                AUTHENTICATED_EXTENDED_CARD_NOT_CONFIGURED,
                "Authenticated Extended Card is not configured"
            ),

            A2AError::DatabaseError(_) => (DATABASE_ERROR, "Database error"),

            // ... rest of cases
        };
        // ... rest of method
    }
}
```

---

### 10. MessageSendConfiguration Update (Low Priority)

**File:** `a2a-rs/src/domain/core/task.rs`

#### Current State
```rust
pub struct MessageSendConfiguration {
    #[serde(rename = "acceptedOutputModes")]
    pub accepted_output_modes: Vec<String>,  // ❌ Should be optional
    // ... other fields
}
```

#### Required Change
```rust
pub struct MessageSendConfiguration {
    #[serde(skip_serializing_if = "Option::is_none", rename = "acceptedOutputModes")]
    pub accepted_output_modes: Option<Vec<String>>,  // ✅ Now optional
    // ... other fields
}
```

**Impact:** Minor breaking change - field is now optional instead of required.

---

## Implementation Plan

### Phase 1: Core Type Updates (Breaking Changes)
**Priority:** Critical
**Estimated Effort:** 4-6 hours

1. ✅ Fix error code conflict (DATABASE_ERROR -32007 → -32100)
2. ✅ Add new error variant `AuthenticatedExtendedCardNotConfigured`
3. ✅ Add `TransportProtocol` enum
4. ✅ Add `AgentInterface` struct
5. ✅ Add `AgentExtension` struct
6. ✅ Update `AgentCard` with v0.3.0 fields
7. ✅ Update `AgentCapabilities` with extensions
8. ✅ Add `extensions` field to `Message`
9. ✅ Add `extensions` field to `Artifact`
10. ✅ Add `id` field to `PushNotificationConfig`
11. ✅ Make `MessageSendConfiguration.accepted_output_modes` optional

**Files to modify:**
- `a2a-rs/src/domain/error.rs`
- `a2a-rs/src/domain/core/agent.rs`
- `a2a-rs/src/domain/core/message.rs`
- `a2a-rs/src/domain/core/task.rs`

### Phase 2: New API Methods - Request/Response Types
**Priority:** High
**Estimated Effort:** 3-4 hours

1. ✅ Add `ListTasksParams`, `ListTasksResult`, `ListTasksRequest`, `ListTasksResponse`
2. ✅ Add `GetTaskPushNotificationConfigParams`
3. ✅ Add list push config types
4. ✅ Add delete push config types
5. ✅ Add authenticated extended card types

**Files to modify:**
- `a2a-rs/src/domain/core/task.rs`
- `a2a-rs/src/application/handlers/task.rs`
- `a2a-rs/src/application/handlers/agent.rs`

### Phase 3: Handler Implementation
**Priority:** High
**Estimated Effort:** 4-6 hours

1. ✅ Implement `tasks/list` handler
2. ✅ Implement `tasks/pushNotificationConfig/list` handler
3. ✅ Implement `tasks/pushNotificationConfig/delete` handler
4. ✅ Update `tasks/pushNotificationConfig/get` handler
5. ✅ Implement `agent/getAuthenticatedExtendedCard` handler

**Files to modify:**
- `a2a-rs/src/application/handlers/task.rs`
- `a2a-rs/src/application/handlers/agent.rs`
- `a2a-rs/src/application/handlers/notification.rs`

### Phase 4: Storage Layer Updates
**Priority:** Medium
**Estimated Effort:** 2-3 hours

1. ✅ Update storage traits for task listing with filters
2. ✅ Add support for multiple push notification configs per task
3. ✅ Add support for authenticated extended cards

**Files to modify:**
- `a2a-rs/src/port/task_manager.rs`
- `a2a-rs/src/adapter/storage/task_storage.rs`
- `a2a-rs/src/adapter/storage/sqlx_storage.rs`

### Phase 5: Testing & Documentation
**Priority:** High
**Estimated Effort:** 4-6 hours

1. ✅ Update existing tests for breaking changes
2. ✅ Add tests for new API methods
3. ✅ Add tests for extension support
4. ✅ Update documentation
5. ✅ Update examples
6. ✅ Create migration guide

**Files to modify:**
- All test files
- `README.md`
- `CHANGELOG.md`
- Examples in `examples/` directory

---

## Breaking Changes for Library Users

Users upgrading to v0.3.0 will encounter the following breaking changes:

### 1. AgentCard Construction
**Before:**
```rust
let card = AgentCard {
    name: "My Agent".to_string(),
    // ... other fields
    signature: Some(my_signature),
    // ...
};
```

**After:**
```rust
let card = AgentCard {
    name: "My Agent".to_string(),
    protocol_version: "0.3.0".to_string(),  // NEW REQUIRED
    // ... other fields
    signatures: Some(vec![my_signature]),  // CHANGED: now a Vec
    // ...
};
```

### 2. Error Code Changes
If users are matching on specific error codes:
```rust
// Before
match error_code {
    -32007 => // This was DATABASE_ERROR
}

// After
match error_code {
    -32007 => // Now AUTHENTICATED_EXTENDED_CARD_NOT_CONFIGURED
    -32100 => // DATABASE_ERROR moved here
}
```

### 3. MessageSendConfiguration
**Before:**
```rust
let config = MessageSendConfiguration {
    accepted_output_modes: vec!["text/plain".to_string()],  // Required
};
```

**After:**
```rust
let config = MessageSendConfiguration {
    accepted_output_modes: Some(vec!["text/plain".to_string()]),  // Optional
};
```

---

## Migration Guide for Users

### Step 1: Update AgentCard Creation
Add the required `protocol_version` field and convert `signature` to `signatures`:

```rust
// Update your AgentCard construction
let card = AgentCard::builder()
    .protocol_version("0.3.0".to_string())  // Add this
    .name("My Agent".to_string())
    // ... other fields
    .signatures(vec![signature])  // Change from .signature(signature)
    .build();
```

### Step 2: Update Error Handling
If you're matching on error codes directly:

```rust
// Update error code constants
const DATABASE_ERROR: i32 = -32100;  // Changed from -32007
const AUTHENTICATED_EXTENDED_CARD_NOT_CONFIGURED: i32 = -32007;  // New
```

### Step 3: Make accepted_output_modes Optional
```rust
let config = MessageSendConfiguration {
    accepted_output_modes: Some(vec!["text/plain".to_string()]),
    // ... other fields
};
```

### Step 4: (Optional) Use New Features

#### Multi-transport Support
```rust
let card = AgentCard::builder()
    .protocol_version("0.3.0".to_string())
    .preferred_transport("JSONRPC".to_string())
    .additional_interfaces(vec![
        AgentInterface {
            url: "https://api.example.com/grpc".to_string(),
            transport: "GRPC".to_string(),
        },
        AgentInterface {
            url: "https://api.example.com/rest".to_string(),
            transport: "HTTP+JSON".to_string(),
        },
    ])
    // ... other fields
    .build();
```

#### Extension Support
```rust
let extension = AgentExtension {
    uri: "https://example.com/extensions/my-extension".to_string(),
    description: Some("My custom extension".to_string()),
    required: Some(false),
    params: None,
};

let capabilities = AgentCapabilities {
    streaming: true,
    push_notifications: true,
    state_transition_history: true,
    extensions: Some(vec![extension]),
};
```

#### Task Listing
```rust
let params = ListTasksParams {
    context_id: Some("ctx-123".to_string()),
    status: Some(TaskState::Working),
    page_size: Some(20),
    history_length: Some(5),
    include_artifacts: Some(true),
    ..Default::default()
};

let request = ListTasksRequest::new(params);
```

---

## Compatibility Notes

### Semantic Versioning
The specification represents a **minor version bump** (v0.2.x → v0.3.0), but includes breaking changes:

- **Breaking:** Required fields added to AgentCard
- **Breaking:** Field renamed (signature → signatures)
- **Breaking:** Error code reassignments
- **Additive:** New API methods
- **Additive:** New types and capabilities
- **Enhancement:** Optional fields added to existing types

### Backward Compatibility
To maintain some backward compatibility, we can:

1. Provide default values where possible (e.g., `protocol_version` defaults to "0.3.0")
2. Use `#[serde(default)]` attributes
3. Accept both old and new formats during deserialization where feasible

However, full backward compatibility is not possible due to the breaking changes in the specification itself.

---

## Testing Strategy

### Unit Tests
- Test all new types serialize/deserialize correctly
- Test error code mappings
- Test builder patterns for new types
- Test validation logic

### Integration Tests
- Test new API endpoints end-to-end
- Test multi-transport scenarios
- Test extension handling
- Test task listing with various filters
- Test multiple push notification configs

### Compatibility Tests
- Test that v0.3.0 agents can communicate properly
- Test error handling for new error codes
- Test migration path from v0.2.x structures

---

## Documentation Updates Required

1. **README.md** - Update version references and feature list
2. **CHANGELOG.md** - Document all v0.3.0 changes
3. **API Documentation** - Add docs for new methods
4. **Migration Guide** - Create detailed migration instructions
5. **Examples** - Update all examples to v0.3.0
6. **Specification Reference** - Link to spec folder

---

## Timeline Estimate

- **Phase 1:** 1 day (core types)
- **Phase 2:** 0.5 days (request/response types)
- **Phase 3:** 1 day (handlers)
- **Phase 4:** 0.5 days (storage)
- **Phase 5:** 1 day (testing & docs)

**Total:** ~4 days of focused development

---

## Risks and Considerations

### Breaking Changes
- Users will need to update code when upgrading
- May require major version bump (0.x → 1.0 or significant minor bump)

### Error Code Conflict
- Moving DATABASE_ERROR code could break existing error handling
- Need clear communication in changelog

### Storage Migration
- Existing databases may need schema updates for new fields
- Consider providing migration scripts for SQLx storage

### Testing Coverage
- Comprehensive testing needed to ensure spec compliance
- Consider JSON Schema validation against spec files

---

## References

- **Specification:** `spec/specification.json`
- **Changelog:** `spec/CHANGELOG.md`
- **README:** `spec/README.md`
- **Current Implementation:** `a2a-rs/src/`

---

## Next Steps

1. Review this plan with stakeholders
2. Create GitHub issues for each phase
3. Begin Phase 1 implementation
4. Set up CI/CD checks for spec compliance
5. Prepare release notes and migration guide
